# 러스트의 메모리 관리

## 다른 언어
> java, Go, Python, JavaScript와 같은 언어들은 GC를 사용하고<br/>
> C, C++과 같은 경우에는 수동으로 프로그래머가 메모리를 관리한다.

## Rust
> Rust는 컴파일 시점에 메모리 관리 규칙을 검사한다.

### 특징

* 소유권 규칙에 따라 컴파일 시점에 메모리 할당/ 해제 관리.
* 규칙에 어긋나면 컴파일되지 않음 - 규칙 지키지 않으면 컴파일 오류
* 규칙을 잘 지키면 컴파일러가 잘 처리를 해줌
* 실행시간 손해가 없으면서도, 실수할 여지가 없음.

### 해제가 될 때
* 블록(scope)가 끝나면 메모리 해제 가능 
```rust
fn main() {
    {
        let s = "hello";
        println!("s = {}", s);
    }
    println!("s = {}", s); // 메모리가 해제되어 불가능
}
```

### Stack과 Heap메모리
#### 문자열 리터럴
* 기본 데이터 타입은 Stack에서 쉽게 관리 가능
* 문자열 리터럴 string literal은 프로그램dp `고정`으로 확보
* 문자열 리터럴은 불면 immutable
#### 문자열 String
* 변경 가능 mutable
* 컴파일 시점에 미리 알 수가없다
* 따라서, Heap 메모리를 차지하게 됨(동적으로 차지한다. -> mutable 하게 사용할 수 있다).
#### 문자열 리터럴 로부터 String 만들기
```rust
fn main() {
    let s = "헬로"; // literal
    let mut s: String = String::from("hello"); // String
    s.push_str(", world!");
}
```
> 실행 시점에 메모리 할당 요청을 하는데
> 만약 메모리 할당한 문자열을 다 쓰고 나면? 
> 사용가능한 메모리로 반환하는 방법이 필요하다.

### 소유권 규칙
> * Rust에서 모든 값은 소유자(owner)가 있다.
> * 한 시점에 딱 하나의 소유자만 있을 수 있다.
> * 소유자의 범위가 끝나면, 값도 제거된다.
#### 소유권 - 값에는 단 하나의 소유자만 가능하다
> 소유권을 넘기는 행위도 가능하며 A가 가지고 있던 값의 소유권을
> B에게 넘긴다면 A가 메모리에서 해제 되어도 값은 그래로이다.<br/>
> 하지만 넘겨받은 B의 메모리가 해제되면 값 또한 해제되게 된다.

코드로 설명하자면
```rust
fn main() {
    {
        let s1 = String::from("hello"); // Heap
        let s2 = s1;
        println!("s2 = {}", s2);
        println!("s1 = {}", s1); // Error!!
    }
    /*
        처음에 s1에 값을 할당할 때 Heap 메모리에 올라가게 된다.
        그런 다음에 s2에 s1을 할당하므로써 소유권을 넘기게 되었다. 
        따라서 더 이상 s1에 접근 할 수 없게된다. 
        
        여기서 놀라운 점은 
        위의 scope가 끝나고 s2의 데이터는 회수하지만
        s1은 더 이상 소유권을 가지고 있지 않아 
        s1에 대해서는 특별한 작업을 하지 않는다. 
        
        즉 메모리 해제 작업은 1번만 일어나게 된다.
        
        ※ Rust는 자체적으로 Heap 데이터를 복사하는 경우는 없다.
    */
}
```
s1, s2모두 같은 값을 가지게 하고 싶다면 clone이라는 함수를 사용해야한다.
```rust
fn main() {
    {
        let s1 = String::from("hello"); // Heap
        let s2 = s1.clone(); // Heap 메모리 복사
        println!("s2 = {}", s2);
        println!("s1 = {}", s1); // Success!!
    }
}
```
---
위와는 반대로 Stack 에서 사용되는 기본 데이터 타입은 Rust가 자동으로 복사를 해준다. <br/>
즉, 따로 소유권개념이 없다고 봐도 무방하다.

기본 데이터 타입에는

|          |                           타입                            |
|:---------|:-------------------------------------------------------:|
| 모든 정수 타입 |                      u32, i64, ...                      |
| 부울 타입    |                    bool(true/false)                     |
| 문자 타입    |                          char                           |
| 튜플       |                       (i32, bool)                       |
| ~~튜플~~   | ~~(i32, String)~~ <br/>※힙에서 관리하는 String이 껴있어 복사가 불가능하다. |

### 함수 호출 시 소유권 이동
> 함수 인자로 넘겨주게 되면 소유권도 넘어가
> 넘겨준 곳에서는 더 이상 사용이 불가능하다.

```rust
fn main() {
    let s = String::from("hello"); // Heap
    string_length(s); // 소유권 전달.
    println!("s = {}", s); // Error!!
}

fn string_length(s:String) {
    println!("문자열의 길이: {}", s); 
}
```
만약 함수에서 s를 그대로 반환 한다면 소유권 또한 다시 돌아오게 된다.
```rust
fn main() {
    let s1 = String::from("hello"); // Heap
    let s2 = calc_length(s1); // 소유권 전달. 및 수령
    println!("s2 = {}", s2);
}

fn calc_length(s:String) -> String {
    println!("문자열의 길이: {}", s);
    s // 소유권 반환
}
```