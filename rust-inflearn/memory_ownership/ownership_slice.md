## 슬라이스(Slice)
> * 어떤 모음에 있는 (일부) 연속된 요소들을 참조하는 방법
> * 참조(Reference)와 마찬가지로 소유권을 넘기지는 않음

예를 들어 주어진 문자열의 첫 단어를 반환하는 함수를 작성해야한다고 생각해보자
```rust
fn main() {
    let s = String::new("hello world");

    // let hello: &str /*문자열 슬라이스 타입 &str*/ = &s[0..6];
    // let hello = &s[..6]
    // let word = &s[..s.len()]
    // let hello_word = &s[..]
    
    let word = first_word(&s); // 함수 사용한다면
    
    println!("word = {}", word);
}

fn first_word(s: &String) -> &str /*문자열 슬라이스*/ {
    /*     
    어떤 로직을 구현해야할까
    
    특정 범위의 인덱스 값을 사용한다 해보자
    원래 문자열이 메모리에서 사라진다거나
    원래 문자열이 중간에 값이 바뀐다면
    인덱스 범위값이 무효해지게 된다.
    
    이럴 때 문자열 slice를 사용할 수 있다.
    기존에 함에 인자로 전달 하였지만 해당 호출부(first_word(&s))를 
    &s[0..6]과 같이 사용한다면 0~5까지의 문자열을 가져오게 된다.
    */
    
    let bytes = s.as_bytes(); // 문자열을 byte 형태로
    
    // index와 해당 byte
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' /*공백까지 b는 byte*/ {
            return &s[..i]
        }
    }
    &s[..]
}
```
우리가 사용하던 일반 문자열 리터럴은 알고보면 `&str`타입이다. 즉 `슬라이스`이다.   
따라서 위 함수의 `인자`로써 `"hello world"`와 같은 값은 `보낼 수 없다.`

하지만 위에서처럼 `&String` 타입으로 매개변수를 받는 것이 아닌 `&str`로 받게 되면   
`&String`또한 `&str`타입이 될 수 있기에 `String과 literal` `모두 받을 수 있게` 된다.

지금까지 사용한 slice는 꼭 문자열이 아닌. 참조 타입이면 모두 가능하다.
즉, 배열, 컬렉션 또한 가능하다.

## 소유권과 임대 정리
> * Rust가 안전하고 빠른 프로그램을 만들게 함
> * 컴파일러가 엄격히 검사하는 메모리 관리 규칙
> * 규칙을 잘 따르면 메모리 해제는 컴파일러가 알아서
> * 소유권의 이전과 임대 개념
> * 슬라이스로 일부 영역 참조도 편하게 // 소유권의 전체가 아닌 일부를 끊어서 사용 가능 
